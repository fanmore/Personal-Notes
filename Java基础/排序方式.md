## 八大排序方式

```
|
|-------内部排序
|          |
|          |------插入排序
|          |         |------直接插入排序
|          |         |------希尔排序
|          |
|          |------选择排序 
|          |         |------简单选择排序
|          |         |------堆排序
|          |
|          |------交换排序
|          |         |------冒泡排序
|          |         |------快速排序
|          |
|          |------归并排序
|          |
|          |------基数排序
|
|-------外部排序
```

### 稳定与非稳定

如果一个排序算法能够保留数组中重复元素的相对位置则可以被称为是稳定的。反之，则是非稳定 的。

### 选择排序

用从小到大排序举例，将第一个元素与后面的元素依次比较，将最小值放在第一个位置；然后用第二个元素与其后面的元素比较将最小值放在该位置；一直下去。

```java
int temp = 0;
for (int i = 0; i < arr.length-1; i++) {
    for (int j = i+1; j <arr.length; j++) {
        if (arr[i] > arr[j]) {
            temp = arr[i];
            arr[i] = arr[j];
            arr[j] = temp;
        }
    }
}
```

* 外层循环控制比较位置。
* 内存循环控制比较次数。

### 冒泡排序

一次比较两个元素，将他们排序，一次遍历会将最大/最小数冒泡到最后。

```java
int temp = 0;
for (int i = 0; i < arr.length-1; i++) {
    for (int j = 0; j < arr.length-i-1; j++) {
        if (arr[j] > arr[j+1]) {
            temp = arr[j];
            arr[j] = arr[j+1];
            arr[j+1] = temp;
        }
    }
}
```

* 外层循环控制起泡次数。
* 内层循环控制比较次数。

### 二分法查找

二分法查找也成为折半查找，适用于数据量较大时，但是数据需要先排好顺序。

```
1   5   8   14   19   22   31
^           ^               ^
low        mid             high
```

```java
// 二分法查找
public static int binarySearch(int[] array, int num) {
    int flag = -1;
    int star = 0;
    int end = array.length-1;
    int mid = 0;
    while(star <= end){
        mid = (star+end)>>2;
        if(array[mid] != num){
            if (array[mid] > num) {
                end = mid - 1;
            }else{
                star = mid + 1;
            }
        }else{
            flag = mid;
            break;
        }
    }
    return flag;
}
```